(* 
Sample1: covcol.c
#pragma scop
  for (j1 = 1; j1 <= M; j1++) {
    for (j2 = j1; j2 <= M; j2++) {
      for (i = 1; i <= N; i++) {
        symmat[j1][j2] += data[i][j1] * data[i][j2];
      }
      symmat[j2][j1] = symmat[j1][j2];
    }
  }
#pragma endscop 
Pluto scheduler unfuse two instructions.
  for (i = 1; i <= N; i++) {
    for (j1 = 1; j1 <= M; j1++) {
      for (j2 = j1; j2 <= M; j2++) {
        symmat[j1][j2] += data[i][j1] * data[i][j2];
      }
    }
  }
  for (j1 = 1; j1 <= M; j1++) {
    for (j2 = j1; j2 <= M; j2++) {
      symmat[j2][j1] = symmat[j1][j2];
    }
  }
And the validator produce "true" bidirectionally, which means two loop nests are equivalent.
*)

(* Its openscop file generated by pluto before scheduling: *)
(*
# [File generated by the OpenScop Library 0.9.2]

<OpenScop>

# =============================================== Global
# Language
C

# Context
CONTEXT
0 5 0 0 0 3

# Parameters are provided
1
<strings>
M N K
</strings>
*)
(*
# Number of statements
1

# =============================================== Statement 1
# Number of relations describing the statement:
8

# ----------------------------------------------  1.1 Domain
DOMAIN
8 7 3 0 0 2
# e/i| j1   j2    i |  M    N |  1  
   1    1    0    0    0    0   -1    ## j1-1 >= 0
   1   -1    0    0    1    0    0    ## -j1+M >= 0
   1    0    0    0    1    0   -1    ## M-1 >= 0
   1   -1    1    0    0    0    0    ## -j1+j2 >= 0
   1    0   -1    0    1    0    0    ## -j2+M >= 0
   1    0    0    1    0    0   -1    ## i-1 >= 0
   1    0    0   -1    0    1    0    ## -i+N >= 0
   1    0    0    0    0    1   -1    ## N-1 >= 0

*)
Require Import PolyBase.
Require Import List.
Import List.ListNotations.
Require Import ZArith.
Require Import CPolIRs.
Open Scope Z_scope.

(**
#pragma scop
  /* Calculate the m * m covariance matrix. */
  for (j1 = 1; j1 <= M; j1++) {
    for (j2 = j1; j2 <= M; j2++) {
      for (i = 1; i <= N; i++) {
        symmat[j1][j2] += data[i][j1] * data[i][j2];
      }
      symmat[j2][j1] = symmat[j1][j2];
    }
  }
#pragma endscop
**)

(** Instruction 1, symmat[j1][j2] += data[i][j1] * data[i][j2]; *)

Definition sample_domain1: Domain := [
    (** M N | j1 j2 i | const *)
    (** 1. -j1 <= -1 (j1 >= 1) *)
    ([0; 0; -1; 0; 0], -1);
    (** 2. j1 - M <= 0 (j1 <= M) *)
    ([-1; 0; 1; 0; 0], 0);
    (** 3. M - 1 >= 0 (-M <= -1)*)
    ([-1; 0; 0; 0; 0], -1);
    (** 4. j1 - j2 <= 0 (-j1+j2 >= 0) *)
    ([0; 0; 1; -1; 0], 0);
    (** 5. j2 <= M *)
    ([-1; 0; 0; 1; 0], 0);
    (** 6. -i <= -1 (1 <= i) *)
    ([0; 0; 0; 0; -1], -1);
    (** 7. i-N <= 0 (i <= N) *)
    ([0; -1; 0; 0; 1], 0);
    (** 8. -N <= -1 (N-1 >= 0) *)
    ([0; -1; 0; 0; 0], -1)
].

(*
# ----------------------------------------------  1.2 Scattering
SCATTERING
7 14 7 3 0 2
# e/i| c1   c2   c3   c4   c5   c6   c7 | j1   j2    i |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    0    0    0    0    0    ## c1 == 0
   0    0   -1    0    0    0    0    0    1    0    0    0    0    0    ## c2 == j1
   0    0    0   -1    0    0    0    0    0    0    0    0    0    0    ## c3 == 0
   0    0    0    0   -1    0    0    0    0    1    0    0    0    0    ## c4 == j2
   0    0    0    0    0   -1    0    0    0    0    0    0    0    0    ## c5 == 0
   0    0    0    0    0    0   -1    0    0    0    1    0    0    0    ## c6 == i
   0    0    0    0    0    0    0   -1    0    0    0    0    0    0    ## c7 == 0
*)

(** (0, j1, 0, j2, 0, i, 0) *)
Definition sample_sctt1: AffineFunction := [
    ([ 0; 0; 0; 0; 0], 0);
    ([ 0; 0; 1; 0; 0], 0);
    ([ 0; 0; 0; 0; 0], 0);
    ([ 0; 0; 0; 1; 0], 0);
    ([ 0; 0; 0; 0; 0], 0);
    ([ 0; 0; 0; 0; 1], 0);
    ([ 0; 0; 0; 0; 0], 0)
].

(* 
# ----------------------------------------------  1.3 Access
WRITE
3 10 3 3 0 2
# e/i| Arr  [1]  [2]| j1   j2    i |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    6    ## Arr == symmat
   0    0   -1    0    1    0    0    0    0    0    ## [1] == j1
   0    0    0   -1    0    1    0    0    0    0    ## [2] == j2
*)

Definition sample_waccess1: list AccessFunction := (
    (** symmat[j1][j2] *)
    6%positive, 
    [
        (** M N | j1 j2 i *)
        ([0; 0; 1; 0; 0], 0);
        ([0; 0; 0; 1; 0], 0)
    ]
)::nil.

(*
READ
3 10 3 3 0 2
# e/i| Arr  [1]  [2]| j1   j2    i |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    6    ## Arr == symmat
   0    0   -1    0    1    0    0    0    0    0    ## [1] == j1
   0    0    0   -1    0    1    0    0    0    0    ## [2] == j2
READ
3 10 3 3 0 2
# e/i| Arr  [1]  [2]| j1   j2    i |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    7    ## Arr == data
   0    0   -1    0    0    0    1    0    0    0    ## [1] == i
   0    0    0   -1    1    0    0    0    0    0    ## [2] == j1

READ
3 10 3 3 0 2
# e/i| Arr  [1]  [2]| j1   j2    i |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    7    ## Arr == data
   0    0   -1    0    0    0    1    0    0    0    ## [1] == i
   0    0    0   -1    0    1    0    0    0    0    ## [2] == j2
*)

Definition sample_raccess1: list AccessFunction := [
    (
        (** symmat[j1][j2] *)
        6%positive, 
        [
            (** M N | j1 j2 i *)
            ([0; 0; 1; 0; 0], 0);
            ([0; 0; 0; 1; 0], 0)
        ]
    );
    (
        (** data[i][j1] *)
        7%positive, 
        [
            (** M N | j1 j2 i *)
            ([0; 0; 0; 0; 1], 0);
            ([0; 0; 1; 0; 0], 0)
        ]
    );
    (
        (** data[i][j2] *)
        7%positive, 
        [
            (** M N | j1 j2 i *)
            ([0; 0; 0; 0; 1], 0);
            ([0; 0; 0; 1; 0], 0)
        ]
    )
].

(* transformation is set as identity *)
Definition sample_transformation1 := [
    ([1; 0; 0; 0; 0], 0);
    ([0; 1; 0; 0; 0], 0);
    ([0; 0; 1; 0; 0], 0);
    ([0; 0; 0; 1; 0], 0);
    ([0; 0; 0; 0; 1], 0)
].



(** Instruction 2, symmat[j2][j1] = symmat[j1][j2]; *)
(*
DOMAIN
5 6 2 0 0 2
# e/i| j1   j2 |  M    N |  1  
   1    1    0    0    0   -1    ## j1-1 >= 0
   1   -1    0    1    0    0    ## -j1+M >= 0
   1    0    0    1    0   -1    ## M-1 >= 0
   1   -1    1    0    0    0    ## -j1+j2 >= 0
   1    0   -1    1    0    0    ## -j2+M >= 0
*)
Definition sample_domain2: Domain := [
    (** M N | j1 j2 | const *)
    (** 1. -j1 <= -1 (j1 >= 1) *)
    ([0; 0; -1; 0], -1);
    (** 2. j1 - M <= 0 (j1 <= M) *)
    ([-1; 0; 1; 0], 0);
    (** 3. M - 1 >= 0 (-M <= -1)*)
    ([-1; 0; 0; 0], -1);
    (** 4. j1 - j2 <= 0 (-j1+j2 >= 0) *)
    ([0; 0; 1; -1], 0);
    (** 5. j2 <= M *)
    ([-1; 0; 0; 1], 0)
].

(*
# ----------------------------------------------  2.2 Scattering
SCATTERING
5 11 5 2 0 2
# e/i| c1   c2   c3   c4   c5 | j1   j2 |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    0    0    ## c1 == 0
   0    0   -1    0    0    0    1    0    0    0    0    ## c2 == j1
   0    0    0   -1    0    0    0    0    0    0    0    ## c3 == 0
   0    0    0    0   -1    0    0    1    0    0    0    ## c4 == j2
   0    0    0    0    0   -1    0    0    0    0    1    ## c5 == 1
*)

(** (0, j1, 0, j2, 0) *)
Definition sample_sctt2: AffineFunction := [
    ([ 0; 0; 0; 0], 0);
    ([ 0; 0; 1; 0], 0);
    ([ 0; 0; 0; 0], 0);
    ([ 0; 0; 0; 1], 0);
    ([ 0; 0; 0; 0], 1)
].

(* 
# ----------------------------------------------  2.3 Access
WRITE
3 9 3 2 0 2
# e/i| Arr  [1]  [2]| j1   j2 |  M    N |  1  
   0   -1    0    0    0    0    0    0    6    ## Arr == symmat
   0    0   -1    0    0    1    0    0    0    ## [1] == j2
   0    0    0   -1    1    0    0    0    0    ## [2] == j1
*)

Definition sample_waccess2: list AccessFunction := (
    (** symmat[j2][j1] *)
    6%positive, 
    [
        (** M N | j1 j2 *)
        ([0; 0; 0; 1], 0);
        ([0; 0; 1; 0], 0)
    ]
)::nil.

(*
READ
3 10 3 3 0 2
# e/i| Arr  [1]  [2]| j1   j2    i |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    6    ## Arr == symmat
   0    0   -1    0    1    0    0    0    0    0    ## [1] == j1
   0    0    0   -1    0    1    0    0    0    0    ## [2] == j2
READ
3 10 3 3 0 2
# e/i| Arr  [1]  [2]| j1   j2    i |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    7    ## Arr == data
   0    0   -1    0    0    0    1    0    0    0    ## [1] == i
   0    0    0   -1    1    0    0    0    0    0    ## [2] == j1

READ
3 10 3 3 0 2
# e/i| Arr  [1]  [2]| j1   j2    i |  M    N |  1  
   0   -1    0    0    0    0    0    0    0    7    ## Arr == data
   0    0   -1    0    0    0    1    0    0    0    ## [1] == i
   0    0    0   -1    0    1    0    0    0    0    ## [2] == j2
*)

Definition sample_raccess2: list AccessFunction := [
    (
        (** symmat[j1][j2] *)
        6%positive, 
        [
            (** M N | j1 j2 i *)
            ([0; 0; 1; 0], 0);
            ([0; 0; 0; 1], 0)
        ]
    )
].

(* transformation is set as identity *)
Definition sample_transformation2 := [
    ([1; 0; 0; 0], 0);
    ([0; 1; 0; 0], 0);
    ([0; 0; 1; 0], 0);
    ([0; 0; 0; 1], 0)
].




(*
<body>
# Number of original iterators
3
# List of original iterators
i j k
# Statement body expression
C[i][j] = beta * C[i][j] + alpha * A[i][k] * B[k][j];
</body>
*)
Require Import CTy.

(* 
Varz: 
2 M (0)
5 N (1)
1 j1(iterator0) (2)
3 j2(iterator1) (3)
4 i(iterator2) (4)
6 symmat
7 data 
*)
Definition sample_cinstr1 := 
    CPolIRs.Instr.Iassign 
        (* symmat[j1=2][j2=3] *)
        (CPolIRs.Instr.Aarr 
            6%positive 
            (CPolIRs.Instr.MAcons (CPolIRs.Instr.MAvarz 2%nat) 
                (CPolIRs.Instr.MAsingleton (CPolIRs.Instr.MAvarz 3%nat)))
            CTy.int32s
        )
        (CPolIRs.Instr.Ebinop
            Cop.Oadd
                (* symmat[j1=2][j2=3] *)
                (CPolIRs.Instr.Eaccess
                    (CPolIRs.Instr.Aarr 
                        6%positive 
                        (CPolIRs.Instr.MAcons (CPolIRs.Instr.MAvarz 2%nat) 
                            (CPolIRs.Instr.MAsingleton (CPolIRs.Instr.MAvarz 3%nat)))
                        CTy.int32s
                    )
                    CTy.int32s
                )
                (*  data[i=4][j1=2] * data[i=4][j2=3] *)
                (CPolIRs.Instr.Ebinop Cop.Omul 
                    (CPolIRs.Instr.Eaccess (CPolIRs.Instr.Aarr 7%positive 
                        (CPolIRs.Instr.MAcons (CPolIRs.Instr.MAvarz 4%nat) 
                            (CPolIRs.Instr.MAsingleton (CPolIRs.Instr.MAvarz 2%nat)))
                        CTy.int32s) CTy.int32s)
                    (CPolIRs.Instr.Eaccess (CPolIRs.Instr.Aarr 7%positive 
                        (CPolIRs.Instr.MAcons (CPolIRs.Instr.MAvarz 4%nat) 
                            (CPolIRs.Instr.MAsingleton (CPolIRs.Instr.MAvarz 3%nat)))
                        CTy.int32s) CTy.int32s)
                    CTy.int32s
                )
            CTy.int32s
        )
.
(* symmat[j2][j1] = symmat[j1][j2]; *)
Definition sample_cinstr2 := CPolIRs.Instr.Iassign 
(* symmat[j2=3][j1=2] *)
(CPolIRs.Instr.Aarr 
    6%positive 
    (CPolIRs.Instr.MAcons (CPolIRs.Instr.MAvarz 3%nat)
        (CPolIRs.Instr.MAsingleton (CPolIRs.Instr.MAvarz 2%nat)))
    CTy.int32s
)
(* symmat[j1=2][j2=3] *)
(CPolIRs.Instr.Eaccess
    (CPolIRs.Instr.Aarr 
        6%positive 
        (CPolIRs.Instr.MAcons (CPolIRs.Instr.MAvarz 2%nat) 
            (CPolIRs.Instr.MAsingleton (CPolIRs.Instr.MAvarz 3%nat)))
        CTy.int32s
    )
    CTy.int32s
)
.

(* 
<arrays>
# Number of arrays
7
# Mapping array-identifiers/array-names
1 j1
2 M
3 j2
4 i
5 N
6 symmat
7 data
</arrays>
*)

Definition sample_pi1 := {|
    CPolIRs.PolyLang.pi_depth := 3%nat;
    CPolIRs.PolyLang.pi_instr := sample_cinstr1; 
    CPolIRs.PolyLang.pi_poly := sample_domain1;
    CPolIRs.PolyLang.pi_transformation := sample_transformation1;
    CPolIRs.PolyLang.pi_schedule := sample_sctt1;
    CPolIRs.PolyLang.pi_waccess := sample_waccess1;
    CPolIRs.PolyLang.pi_raccess := sample_raccess1;
|}.

Definition sample_pi2 := {|
    CPolIRs.PolyLang.pi_depth := 2%nat;
    CPolIRs.PolyLang.pi_instr := sample_cinstr2; 
    CPolIRs.PolyLang.pi_poly := sample_domain2;
    CPolIRs.PolyLang.pi_transformation := sample_transformation2;
    CPolIRs.PolyLang.pi_schedule := sample_sctt2;
    CPolIRs.PolyLang.pi_waccess := sample_waccess2;
    CPolIRs.PolyLang.pi_raccess := sample_raccess2;
|}.

Definition sample_pis := 
    [sample_pi1; sample_pi2] 
.

Definition sample_varctxt := 
    [2%positive; 5%positive].

Definition sample_vars := 
    [
  (1%positive, CTy.arr_type_intro CTy.int32s []); 
  (2%positive, CTy.arr_type_intro CTy.int32s []); 
  (3%positive, CTy.arr_type_intro CTy.int32s []); 
  (4%positive, CTy.arr_type_intro CTy.int32s []); 
  (5%positive, CTy.arr_type_intro CTy.int32s []); 
  (6%positive, CTy.arr_type_intro CTy.int32s [100;100]); 
  (7%positive, CTy.arr_type_intro CTy.int32s [100;100])].

Definition sample_cpol := (
  sample_pis, 
  sample_varctxt,
  sample_vars
).


Example waccesses_ok:
    opt_access_subset (CPolIRs.Instr.waccess sample_cinstr1) (Some sample_waccess1) = true /\
    opt_access_subset (CPolIRs.Instr.waccess sample_cinstr2) (Some sample_waccess2) = true.
Proof. simpl. firstorder. Qed.

Example raccesses_ok:
    opt_access_subset (CPolIRs.Instr.raccess sample_cinstr1) (Some sample_raccess1) = true /\
    opt_access_subset (CPolIRs.Instr.raccess sample_cinstr2) (Some sample_raccess2) = true.
Proof. simpl. firstorder. Qed.
