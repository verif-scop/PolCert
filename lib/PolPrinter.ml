(* open CPol  *)
open Printf 
open CPolIRs 
open Camlcoq
let version = "0.1"

(* cinstr itself cannot differentiate constant symbol and iterators. *)
let cinstr_printer out cinstr =
  fprintf out "Instr: %s\n" "<placeholder>";
  fprintf out "Depth: %d" (Nat.to_int (CPolIRs.Instr.depth cinstr));
  fprintf out "\n"
  (* List.iter (fun ident -> fprintf out "%s " (extern_atom ident)) (CPolIRs.Instr.iters cinstr); *)

let varctxt_printer out varctxt = 
  fprintf out "<VarCtxt>  # Constant variables exist in poly-related expressions\n";
  List.iter (fun ident -> fprintf out "%s " (extern_atom ident)) varctxt;
  fprintf out "\n</VarCtxt>\n"

(* TODO *)
let type_str ty = 
    let bty_str = "int" in
    let bounds_str = List.fold_left (fun acc bound -> 
      acc ^ "[" ^ (Z.to_string bound) ^ "]"
    ) "" ty in
    bty_str ^ bounds_str

let vars_printer out vars = 
  fprintf out "<Vars>  # All variables exist in the fragment\n";
  List.iter (fun id_ty -> 
    let (ident, ty) = id_ty in
    fprintf out "%s %s\n" (extern_atom ident) (type_str ty)) vars;
  fprintf out "\n</Vars>\n"

let listzz_printer out constr = 
  let (zs, z) = constr in
  List.iter (fun z -> fprintf out "%d " (Z.to_int z)) zs;
  fprintf out "; %d\n" (Z.to_int z)

let listzzs_printer out domain = 
  List.iter (fun constr -> 
    listzz_printer out constr
  ) domain

let access_printer out access rw = 
  let (id, listzzs) = access in 
  fprintf out "%s: %s\n" rw (extern_atom id); 
  listzzs_printer out listzzs

let pi_printer out idx pi = 
  cinstr_printer out pi.CPolIRs.PolyLang.pi_instr;
  fprintf out "# ----------------------------------------------  %d.%d Domain\n" idx 1;
  listzzs_printer out pi.CPolIRs.PolyLang.pi_poly;
  fprintf out "# ----------------------------------------------  %d.%d Schedule\n" idx 2;
  listzzs_printer out pi.CPolIRs.PolyLang.pi_schedule;
  (* fprintf out "# ----------------------------------------------  %d.%d Write Access\n" idx 3; *)
  (* access_printer out pi.CPolIRs.PolyLang.pi_waccess "Write to"; *)
  List.iteri (fun idx' raccess -> 
    fprintf out "# ----------------------------------------------  %d.%d.%d Write Access \n" idx 3 (idx'+1);
    access_printer out raccess "Write to";
  ) pi.CPolIRs.PolyLang.pi_waccess;
  List.iteri (fun idx' raccess -> 
    fprintf out "# ----------------------------------------------  %d.%d.%d Read Access\n" idx 4 (idx'+1);
    access_printer out raccess "Read from";
  ) pi.CPolIRs.PolyLang.pi_raccess;
  fprintf out "\n"

let pis_printer out pis = 
  fprintf out "# =============================================== Polyhedral Instructions \n";
  fprintf out "# Number of Instructions:\n%d\n" (List.length pis);
  List.iteri (fun idx pi -> 
    fprintf out "# =============================================== Instruction %d\n" (idx+1);
    (* fprintf out "# Number of relations describing the statement:\n%d\n\n" (2 + (List.length stmt.waccess));  *)
    pi_printer out (idx+1) pi
  ) pis

let cpol_printer' out cpol= 
  let ((pis, varctxt), vars) = cpol in
  fprintf out "# [File generated by coq-openscop %s]\n\n" version;
  fprintf out "<CPol> \n";
  varctxt_printer out varctxt; 
  vars_printer out vars;
  pis_printer out pis;
  fprintf out "</CPol>\n"


let cpol_printer filename (cpol: CPolIRs.PolyLang.t) = 
  let out = open_out filename in
  cpol_printer' out cpol;
  close_out out
;;
  (* printf "cpol printer not implemented\n" ;;  *)
